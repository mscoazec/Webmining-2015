<!DOCTYPE html>
<html>
<head>
    <title>Leaflet Map</title>
    <meta charset="utf-8" />
    <link 
        rel="stylesheet" 
        href="http://cdn.leafletjs.com/leaflet-0.5/leaflet.css"
    />
	<style>
		.info {
			padding: 6px 8px;
			font: 14px/16px Arial, Helvetica, sans-serif;
			background: white;
			background: rgba(255,255,255,0.8);
			box-shadow: 0 0 15px rgba(0,0,0,0.2);
			border-radius: 5px;
		}
		.info h4 {
			margin: 0 0 5px;
			color: #777;
		}

		.legend {
			text-align: left;
			line-height: 18px;
			color: #555;
		}
		.legend i {
			width: 18px;
			height: 18px;
			float: left;
			margin-right: 8px;
			opacity: 0.5;
		}
		table, th, td {
			padding: 3px;
		}
	</style>
</head>
<body>
    <div id="map" style="width: 1600px; height: 900px"></div>

    <script src="http://cdn.leafletjs.com/leaflet-0.5/leaflet.js"></script>
    <script src="./communes-75.json"></script>
    <script>
	
		// create map on Paris
			
		// layer on map -- which map (openstreetmap for instance...)
		
		var mbAttr = 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, ' +
				'<a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
				'Imagery © <a href="http://mapbox.com">Mapbox</a>',
			mbUrl = 'https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6IjZjNmRjNzk3ZmE2MTcwOTEwMGY0MzU3YjUzOWFmNWZhIn0.Y8bhBaUMqFiPrDRW9hieoQ';

	    var grayscale   = L.tileLayer(mbUrl, {id: 'mapbox.light', attribution: mbAttr}),
		    streets  = L.tileLayer(mbUrl, {id: 'mapbox.streets',   attribution: mbAttr});
		
		var baseLayers = {
			"Rues": streets,
			"Niveaux de gris": grayscale
		};
		
		var mines = L.marker([48.845444, 2.339375]).bindPopup('Ici MINES Paristech'),
			telecom = L.marker([48.826506, 2.346462]).bindPopup('Ici Télécom Paristech');

		var places = L.layerGroup([mines, telecom]);
		
		var basePlaces = {
			"Quelques lieux": places
		};
				
		var map = L.map('map', {
			center: [48.8555875, 2.3366803],
			zoom: 13,
			layers: [streets, places]
		});
		
		currentLayer = "m_prix_surface";
		
		// ------------------------------------------
		
		// import geojson data
					
		// --------------------- style

		// feature style
		
		var grades_prix_surface = [7000, 8000, 9000, 10000, 11000, 12000, 14000]
		var grades_prix = [400000, 600000, 800000, 900000, 1000000, 1200000, 1400000]
		var grades_surface = [40, 50, 60, 70, 80, 90, 100]
		var grades_ratio = [10, 20, 30, 40, 50, 60, 70, 80]
		
		var colormap_r = ['#1A0000', '#660000', '#990000', '#CC0000', '#FF0000', '#FF4D4D', '#FF8080', '#FFB2B2']
		var colormap_b = ['#00141A', '#003D4C', '#006680', '#008FB2', '#00B8E6', '#33D6FF', '#80E6FF', '#CCF5FF']
		var colormap_j = ['#331F00', '#804C00', '#B26B00', '#E68A00', '#FFA319', '#FFAD33', '#FFC266', '#FFC266']
		var colormap_v = ['#002E0F', '#004C1A', '#007A29', '#009933', '#33AD5C', '#66C285', '#B2E0C2', '#E6F5EB']
		
		function getColor(d, mode) {
		
		if (mode == "prix_surface") {
			var grades = grades_prix_surface;
			var colormap = colormap_r}
		if (mode == "prix") {
			var grades = grades_prix;
			var colormap = colormap_j}
		if (mode == "surface") {
			var grades = grades_surface;
			var colormap = colormap_v}
		if (mode == "ratio") {
			var grades = grades_ratio;
			var colormap = colormap_b}
			
			return d > grades[6] ? colormap[0] :
				   d > grades[5] ? colormap[1] :
				   d > grades[4] ? colormap[2] :
				   d > grades[3] ? colormap[3] :
				   d > grades[2] ? colormap[4] :
				   d > grades[1] ? colormap[5] :
				   d > grades[0] ? colormap[6] :
							   colormap[7];
	    }

		
		function style_prix_surface(feature) {
			return {
				fillColor: getColor(feature.properties.m_prix/feature.properties.m_surface, "prix_surface"),
				weight: 2,
				opacity: 1,
				color: 'white',
				fillOpacity: 0.5
			};
		}
		
		function style_surface(feature) {
			return {
				fillColor: getColor(feature.properties.m_surface, "surface"),
				weight: 2,
				opacity: 1,
				color: 'white',
				fillOpacity: 0.5
			};
		}
		
		function style_prix(feature) {
			return {
				fillColor: getColor(feature.properties.m_prix, "prix"),
				weight: 2,
				opacity: 1,
				color: 'white',
				fillOpacity: 0.5
			};
		}
		
		var labels = communesData.features[0].properties;
		
		function style_label(l) {
			
			return function style(feature) {
				return {
					fillColor: getColor(feature.properties[l]*100, "ratio"),
					weight: 2,
					opacity: 1,
					color: 'white',
					fillOpacity: 0.5
				};
			}
		};
		
		
		var legend_ratio = L.control({position: 'topleft'});

		legend_ratio.onAdd = function (map) {

			var div = L.DomUtil.create('div', 'info legend'),
				grades = grades_ratio,
				labels = [];

			// loop through our density intervals and generate a label with a colored square for each interval
			for (var i = 0; i < grades.length; i++) {
				div.innerHTML +=
					'<i style="background:' + getColor(grades[i] + 1, "ratio") + '"></i> ' +
					grades[i] + (grades[i + 1] ? '&ndash;' + grades[i + 1] + ' %' + '<br>' : ' +');
			}

			return div;
			
		};
		
		var legend_prix_surface = L.control({position: 'topleft'});

		legend_prix_surface.onAdd = function (map) {

			var div = L.DomUtil.create('div', 'info legend'),
				grades = grades_prix_surface,
				labels = [];

			// loop through our density intervals and generate a label with a colored square for each interval
			for (var i = 0; i < grades.length; i++) {
				div.innerHTML +=
					'<i style="background:' + getColor(grades[i] + 1, "prix_surface") + '"></i> ' +
					grades[i]/1000 + (grades[i + 1] ? '&ndash;' + grades[i + 1]/1000 + ' k€/m²' + '<br>' : ' +');
			}

			return div;
			
		};
		
		var legend_prix = L.control({position: 'topleft'});

		legend_prix.onAdd = function (map) {

			var div = L.DomUtil.create('div', 'info legend'),
				grades = grades_prix,
				labels = [];

			// loop through our density intervals and generate a label with a colored square for each interval
			for (var i = 0; i < grades.length; i++) {
				div.innerHTML +=
					'<i style="background:' + getColor(grades[i] + 1, "prix") + '"></i> ' +
					grades[i]/1000000 + (grades[i + 1] ? '&ndash;' + grades[i + 1]/1000000 + ' M€' + '<br>' : ' +');
			}

			return div;
		};
		
		var legend_surface = L.control({position: 'topleft'});

		legend_surface.onAdd = function (map) {

			var div = L.DomUtil.create('div', 'info legend'),
				grades = grades_surface,
				labels = [];

			// loop through our density intervals and generate a label with a colored square for each interval
			for (var i = 0; i < grades.length; i++) {
				div.innerHTML +=
					'<i style="background:' + getColor(grades[i] + 1, "surface") + '"></i> ' +
					grades[i] + (grades[i + 1] ? '&ndash;' + grades[i + 1] + ' m²' + '<br>' : ' +');
			}

			return div;
		};
		
		// mouseover event
		
		dicoSite = {'pap': 'PAP', 'explorimmo': 'Explorimmo', 'paruvendu': 'ParuVendu', 'seloger': 'Se Loger', 'fnaim': 'FNAIM', 'laforet': 'La Forêt'}
		
		var icones = {};
		
		icones['pap'] = L.icon({
			iconUrl: 'logo-pap.png',
			iconSize:     [80, 50], // size of the icon
			iconAnchor:   [40, 25], // point of the icon which will correspond to marker's location
			popupAnchor:  [0, 0] // point from which the popup should open relative to the iconAnchor
		});
		
		icones['explorimmo'] = L.icon({
			iconUrl: 'logo-explorimmo.png',
			iconSize:     [120, 30], // size of the icon
			iconAnchor:   [60, 15], // point of the icon which will correspond to marker's location
			popupAnchor:  [0, 0] // point from which the popup should open relative to the iconAnchor
		});
		
		icones['paruvendu'] = L.icon({
			iconUrl: 'logo-paruvendu.png',
			iconSize:     [120, 18], // size of the icon
			iconAnchor:   [60, 9], // point of the icon which will correspond to marker's location
			popupAnchor:  [0, 0] // point from which the popup should open relative to the iconAnchor
		});
		
		icones['seloger'] = L.icon({
			iconUrl: 'logo-seloger.png',
			iconSize:     [110, 34], // size of the icon
			iconAnchor:   [55, 17], // point of the icon which will correspond to marker's location
			popupAnchor:  [0, 0] // point from which the popup should open relative to the iconAnchor
		});
		
		icones['fnaim'] = L.icon({
			iconUrl: 'logo-fnaim.png',
			iconSize:     [90, 70], // size of the icon
			iconAnchor:   [45, 35], // point of the icon which will correspond to marker's location
			popupAnchor:  [0, 0] // point from which the popup should open relative to the iconAnchor
		});
		
		icones['laforet'] = L.icon({
			iconUrl: 'logo-laforet.png',
			iconSize:     [60, 60], // size of the icon
			iconAnchor:   [30, 30], // point of the icon which will correspond to marker's location
			popupAnchor:  [0, 0] // point from which the popup should open relative to the iconAnchor
		});
		
		mark = {}
		
		function highlightFeature(e) {
			var layer = e.target;

			layer.setStyle({
				weight: 7,
				color: 'white',
				dashArray: '',
				fillOpacity: 0.5
			});

			if (!L.Browser.ie && !L.Browser.opera) {
				layer.bringToFront();
			}
			
			info.update(layer.feature.properties);
			
			console.log(layer.feature.properties.nom)
			
			if (!(layer.feature.properties.nom in mark)) {
			
				s = layer.feature.properties.nom + '<br>' + '<br>'
				s = s + "Meilleurs offres sur : " + '<b>' + dicoSite[layer.feature.properties["gagnant"][currentLayer]] + '<br>' + '<br>'
				
				s = s + '<table>'
				
				for (si in dicoSite) {
				
					s = s + '<tr> <td>' + dicoSite[si] + '</td>' + '<td> <b>' + layer.feature.properties[si][currentLayer] + '</td> </tr>'
				
				}
				
				s = s + '</table>'
					
				polygon_center = layer.getBounds().getCenter();
				mark[layer.feature.properties.nom] = L.marker([polygon_center.lat, polygon_center.lng], {icon: icones[layer.feature.properties["gagnant"][currentLayer]]}).addTo(map).bindPopup(s);
			
			}
			
		}
		
		// mouseout event
		
		function resetHighlight(e) {
			var layer = e.target;

			layer.setStyle({
				weight: 1,
				color: 'white',
				dashArray: '',
				fillOpacity: 0.5
			});
			
			info.update();
		}
		
		// on map click
		
		var popup = L.popup();
		
		function onMapClick(e) {
			/* popup
				.setLatLng(e.latlng)
				.setContent("Ce point a pour coordonnées : " + Math.round(e.latlng.lat*1000)/1000 + ", " + Math.round(e.latlng.lng*1000)/1000)
				.openOn(map); */
		}
				
		// --------------------- add geojson data to map
		
		// function to add the listeners
		
		function onEachFeature(feature, layer) {
		
			layer.on({
				mouseover: highlightFeature,
				mouseout: resetHighlight,
				click: onMapClick
			});
			
		}
		
		// add geojson data to map with style and listeners
		
		var arr_prix_surface = L.geoJson(communesData, {
			style: style_prix_surface,
			onEachFeature: onEachFeature,
			name: "m_prix_surface"
		})
		
		var arr_prix = L.geoJson(communesData, {
			style: style_prix,
			onEachFeature: onEachFeature,
			name: "m_prix"
		})
		
		var arr_surface = L.geoJson(communesData, {
			style: style_surface,
			onEachFeature: onEachFeature,
			name: "m_surface"
		})

		var arr = {};
		
		for (l in labels) {
			
			arr[String(l)] = L.geoJson(communesData, {
				style: style_label(l),
				onEachFeature: onEachFeature,
				name: l
			})
			
		}
		
		console.log(arr_prix_surface)
		
		var geoLayers = {
		
			"Répartition du prix au mètre carré": arr_prix_surface,
			"... des biens chers": arr_prix,
			"... des grandes surfaces": arr_surface,
			
			"... des studios": arr["m_studio"],
			
			"... des ascenseurs": arr["m_ascenseur"],
			"... des gardiens": arr["m_gardien"],
			"... des parkings": arr["m_parking"],
			
			"... des cuisines": arr["m_cuisine"],
			"... des cuisines américaines": arr["m_cuisine_americaine"],
			"... des cuisines équipées": arr["m_cuisine_equipee"],
			"... des WC séparés": arr["m_wc_separes"],
			"... des buanderies": arr["m_buanderie"],
			"... des baignoires": arr["m_baignoire"],
			
			"... des balcons": arr["m_balcon"],
			"... des terrasses": arr["m_terrasse"],
			"... du parquet": arr["m_parquet"],
			
			"... des jardins ": arr["m_jardin"],
			"... des orientations Sud": arr["m_orientation_sud"],
			"... de la luminosité": arr["m_lumineux"],
			"... du calme": arr["m_calme"],

			"... du style Haussmann": arr["m_haussmann"],
		};
		
				
		// --------------------- listeners
		
		// control that shows state info on hover
		
		var info = L.control({position: 'topright'});

		info.onAdd = function (map) {
			this._div = L.DomUtil.create('div', 'info');
			this.update();
			return this._div;
		};

		info.update = function (props) {
		
			bold = '<b>';
			
			b = {};
			b["m_prix_surface"] = [];
			for (l in labels) {
				b[l] = '';
			}
			b[currentLayer] = bold;
		
			this._div.innerHTML = '<h4> Nom</h4>' +  (props ?
				'<b>' + props.nom + '</b><br />' + '</b><br />' +
				
				'<table>' +
				
				'<tr> <td>' + "Nombre d'appartements en vente : " + '</td>' +
				'<td> <b>' + props.nb_apparts + '</td> </tr>' +
				
				'<tr> <td>' + b["m_prix_surface"] + "Prix par mètre carré en moyenne : " + '</td>' +
				'<td> <b>' + parseInt(props.m_prix/props.m_surface) + ' € / m²' + '</td> </tr>' +
				
				'<tr> <td>' + b["m_prix"] + "Prix moyen des ventes : " + '</td>' +
				'<td> <b>' + parseInt(props.m_prix/1000) + ' k€' + '</td> </tr>' +
				
				'<tr> <td>' + b["m_surface"] + "Surface moyenne des ventes : " + '</td>' +
				'<td> <b>' + parseInt(props.m_surface) + ' m²' + '</td> </tr>' +
				
				'<tr> <td>' + b["m_studio"] + "Studios : " + '</td>' +
				'<td> <b>' + parseInt(props.m_studio*100) + ' %' + '</td> </tr>' +
				
				'<tr> <td>' + b["m_ascenseur"] + "Appartements avec ascenseur : " + '</td>' +
				'<td> <b>' + parseInt(props.m_ascenseur*100) + ' %' + '</td> </tr>' +
				
				'<tr> <td>' + b["m_gardien"] + "... avec gardien : " + '</td>' +
				'<td> <b>' + parseInt(props.m_gardien*100) + ' %' + '</td> </tr>' +
				
				'<tr> <td>' + b["m_parking"] + "... avec parking : " + '</td>' +
				'<td> <b>' + parseInt(props.m_parking*100) + ' %' + '</td> </tr>' +
				
				'<tr> <td>' + b["m_cuisine"] + "... avec cuisine : " + '</td>' +
				'<td> <b>' + parseInt(props.m_cuisine*100) + ' %' + '</td> </tr>' +
				
				'<tr> <td>' + b["m_cuisine_americaine"] + "... avec cuisine américaine : " + '</td>' +
				'<td> <b>' + parseInt(props.m_cuisine_americaine*100) + ' %' + '</td> </tr>' +
				
				'<tr> <td>' + b["m_cuisine_equipee"] + "... avec cuisine équipée : " + '</td>' +
				'<td> <b>' + parseInt(props.m_cuisine_equipee*100) + ' %' + '</td> </tr>' +
				
				'<tr> <td>' + b["m_wc_separes"] + "... avec WC séparés : " + '</td>' +
				'<td> <b>' + parseInt(props.m_wc_separes*100) + ' %' + '</td> </tr>' +
				
				'<tr> <td>' + b["m_buanderie"] + "... avec buanderie : " + '</td>' +
				'<td> <b>' + parseInt(props.m_buanderie*100) + ' %' + '</td> </tr>' +
				
				'<tr> <td>' + b["m_baignoire"] + "... avec baignoire : " + '</td>' +
				'<td> <b>' + parseInt(props.m_baignoire*100) + ' %' + '</td> </tr>' +
				
				'<tr> <td>' + b["m_balcon"] + "... avec balcon : " + '</td>' +
				'<td> <b>' + parseInt(props.m_balcon*100) + ' %' + '</td> </tr>' +
				
				'<tr> <td>' + b["m_terrasse"] + "... avec terrasse : " + '</td>' +
				'<td> <b>' + parseInt(props.m_terrasse*100) + ' %' + '</td> </tr>' +
				
				'<tr> <td>' + b["m_parquet"] + "... avec parquet : " + '</td>' +
				'<td> <b>' + parseInt(props.m_parquet*100) + ' %' + '</td> </tr>' +
				
				'<tr> <td>' + b["m_jardin"] + "... avec jardin : " + '</td>' +
				'<td> <b>' + parseInt(props.m_jardin*100) + ' %' + '</td> </tr>' +
				
				'<tr> <td>' + b["m_orientation_sud"] + "... avec orientation Sud : " + '</td>' +
				'<td> <b>' + parseInt(props.m_orientation_sud*100) + ' %' + '</td> </tr>' +
				
				'<tr> <td>' + b["m_lumineux"] + "... lumineux : " + '</td>' +
				'<td> <b>' + parseInt(props.m_lumineux*100) + ' %' + '</td> </tr>' +
				
				'<tr> <td>' + b["m_calme"] + "... calme : " + '</td>' +
				'<td> <b>' + parseInt(props.m_calme*100) + ' %' + '</td> </tr>' +
				
				'<tr> <td>' + b["m_haussmann"] + "... de style hausmannien : " + '</td>' +
				'<td> <b>' + parseInt(props.m_haussmann*100) + ' %' + '</td> </tr>' +
				
				'</table>'
				
				: '</b><br />' + 'Passez la souris sur un arrondissement' + '</b><br />'
				
				);
		};

		info.addTo(map);
		
		L.control.layers(baseLayers, basePlaces, {position:'topleft'}).addTo(map);
		L.control.layers(geoLayers, {}, {collapsed:false, position:'bottomleft'}).addTo(map);
		
		arr_prix_surface.addTo(map);
		
		legend_prix_surface.addTo(map);
		currentLegend = legend_prix_surface;
		
		map.on('baselayerchange', function (eventLayer) {
			// change les légendes ...
			this.removeControl(currentLegend);
			
			for (m in mark) {
				this.removeLayer(mark[m]);
			}
			
			mark = {}
			
			s = String(eventLayer.layer.options.style)
			e = s.split(" ")[1]
			
			if (e === 'style_prix_surface(feature)') {
				currentLegend = legend_prix_surface;
				currentLayer = "m_prix_surface"
				}
			else if (e === 'style_surface(feature)') {
				currentLegend = legend_surface;
				currentLayer = "m_surface"
				}
			else if (e === 'style_prix(feature)') {
				currentLegend = legend_prix;
				currentLayer = "m_prix"
				}
			else if (e === 'style(feature)') {
				currentLegend = legend_ratio;
				currentLayer = eventLayer.layer.options.name
				}
			
			currentLegend.addTo(this);
			
		});

		// ------------------------------------------
		
    </script>
</body>
</html>